{"_elements":[{"tag":"NarrativeStatement","_statementValenceReason":{"tag":"ByDefinition","contents":[]},"_statementCause":{"tag":"Given","contents":[]},"_statementValence":0.0,"_statementId":"id1","_statementType":"CH","_statementFact":{"tag":"Fact","_factArguments":[{"tag":"IdArgument","contents":"dog"},{"tag":"IdArgument","contents":"animal"}],"_factId":"isa"},"_narrativePoint":"np1"},{"tag":"NarrativeStatement","_statementValenceReason":{"tag":"Assumed","contents":[]},"_statementCause":{"tag":"InferredBy","contents":["id5"]},"_statementValence":1,"_statementId":"id2","_statementType":"CH","_statementFact":{"tag":"Fact","_factArguments":[{"tag":"IdArgument","contents":"dog"},{"tag":"IdArgument","contents":"run"},{"tag":"IdArgument","contents":"fun"}],"_factId":"doesfor"},"_narrativePoint":"np1"},{"tag":"NarrativeStatement","_statementValenceReason":{"tag":"Assumed","contents":[]},"_statementCause":{"tag":"InferredBy","contents":["id6"]},"_statementValence":0.0,"_statementId":"id3","_statementType":"CH","_statementFact":{"tag":"Not","_negatedFact":{"tag":"Fact","_factArguments":[{"tag":"IdArgument","contents":"dog"},{"tag":"IdArgument","contents":"ride_horse"}],"_factId":"capableof"}},"_narrativePoint":"np1"},{"tag":"NarrativeStatement","_statementValenceReason":{"tag":"Assumed","contents":[]},"_statementCause":{"tag":"Given","contents":[]},"_statementValence":-1,"_statementId":"id4","_statementType":"CH","_statementFact":{"tag":"Fact","_factArguments":[{"tag":"IdArgument","contents":"dog"},{"tag":"IdArgument","contents":"old"}],"_factId":"hasproperty"},"_narrativePoint":"np2"},{"tag":"NarrativeStatement","_statementValenceReason":{"tag":"Assumed","contents":[]},"_statementCause":{"tag":"Given","contents":[]},"_statementValence":-1,"_statementId":"id5","_statementType":"CH","_statementFact":{"tag":"Not","_negatedFact":{"tag":"Fact","_factArguments":[{"tag":"IdArgument","contents":"dog"},{"tag":"IdArgument","contents":"run"}],"_factId":"capableof"}},"_narrativePoint":"np2"},{"tag":"NarrativeStatement","_statementValenceReason":{"tag":"ValenceInferredBy","contents":["id7"]},"_statementCause":{"tag":"Given","contents":[]},"_statementValence":1,"_statementId":"id6","_statementType":"EV","_statementFact":{"tag":"Fact","_factArguments":[{"tag":"IdArgument","contents":"dog"},{"tag":"IdArgument","contents":"ride_horse"}],"_factId":"learnto"},"_narrativePoint":"np3"},{"tag":"NarrativeStatement","_statementValenceReason":{"tag":"ValenceInferredBy","contents":["id8"]},"_statementCause":{"tag":"CausedBy","contents":["id6"]},"_statementValence":1,"_statementId":"id7","_statementType":"CH","_statementFact":{"tag":"Fact","_factArguments":[{"tag":"IdArgument","contents":"dog"},{"tag":"IdArgument","contents":"ride_horse"}],"_factId":"capableof"},"_narrativePoint":"np3"},{"tag":"NarrativeStatement","_statementValenceReason":{"tag":"Assumed","contents":[]},"_statementCause":{"tag":"InferredBy","contents":["id2"]},"_statementValence":1,"_statementId":"id8","_statementType":"CH","_statementFact":{"tag":"Fact","_factArguments":[{"tag":"IdArgument","contents":"dog"},{"tag":"IdArgument","contents":"ride_horse"},{"tag":"IdArgument","contents":"fun"}],"_factId":"doesfor"},"_narrativePoint":"np3"},{"tag":"Schema","_schemaId":"np1","_schemaType":"Setting"},{"tag":"Schema","_schemaId":"np2","_schemaType":"Conflict"},{"tag":"Schema","_schemaId":"np3","_schemaType":"Resolution"},{"_metadata":{"tag":"MainCharacter","contents":"dog"},"tag":"Metadata"},{"_metadata":{"tag":"ConflictEvent","contents":"id8"},"tag":"Metadata"},{"_metadata":{"tag":"ResolutionEvent","contents":"id11"},"tag":"Metadata"},{"_metadata":{"tag":"RealityDistortions","contents":["id3"]},"tag":"Metadata"},{"_metadata":{"tag":"FictionalAdditions","contents":["id2","id8","id12","id13"]},"tag":"Metadata"},{"tag":"Rules","contents":"%<\n\n\n:- use_module(library(http/http_open)).\n:- use_module(library(http/http_client)).\n:- use_module(library(date)).\n:- use_module(library(apply)).\n\n:- dynamic main_character/1.\n\n\n%X = personaje_secundario, Y = accion (p.e.: 'dog eats ___'), atomic_list_concat(Words, '___', Y), atomic_list_concat(Words, X, Result).\n\n/* Obtener acciones del servicio Cambridge */\n\n/*\n  ACTION: la acci├│n a realizar\n  SUBJECT_TYPE: empty/protagonist/something/text\n  SUBJECT_TEXT: texto\n  OBJECT_TYPE: empty/protagonist/something/text\n  OBJECT_TEXT: texto\n  PREPOSITION: texto\n  IO_TYPE: empty/protagonist/text\n  IO_TEXT: texto\n  PROTAGONIST: texto\n\n  Ej: \"dog eats itself\" -> doform(eats, protagonist, '', protagonist, '', '', empty, '', dog).\n*/\n\nfetch_actions_from_ws(A, STY, STXT, OTY, OTXT, PRP, IOTY, IOTXT, PROT, Js) :-\n              string_concat('http://ccg02.doc.gold.ac.uk/eventchains3/entity_narrative/api/query/word2vec/gigaword-300-full-with-args-trans-adj/?action=', A, P1),\n              string_concat(P1, '&subject_type=', P2),\n              string_concat(P2, STY, P3),\n              string_concat(P3, '&subject_text=', P4),\n              string_concat(P4, STXT, P5),\n              string_concat(P5, '&object_type=', P6),\n              string_concat(P6, OTY, P7),\n              string_concat(P7, '&object_text=', P8),\n              string_concat(P8, OTXT, P9),\n              string_concat(P9, '&preposition=', P10),\n              string_concat(P10, PRP, P11),\n              string_concat(P11, '&indirect_object_type=', P12),\n              string_concat(P12, IOTY, P13),\n              string_concat(P13, '&indirect_object_text=', P14),\n              string_concat(P14, IOTXT, P15),\n              string_concat(P15, '&limit=10&protagonist=', P16),\n              string_concat(P16, PROT, P17),\n              string_concat(P17, '&unique_predicates=0', URL),\n              http_open(URL,In, []),\n              json_read(In, Js),\n              close(In).\n\n/* TODO: sacar la acci├│n pasada como argumento: action(S, O) */\nfetch_actions(Ev, AcJSON) :- parse_action(Ev, Ac, Sj, Ob),\n        fetch_actions_from_ws(Ac, protagonist, '', text, Ob, '', empty, '', Sj, AcJSON).\n\nparse_action(Ev, Ac, Sj, Ob) :- format(atom(EvAtom), \"~w\", Ev), split_string(EvAtom, \"(,\", \"() \", [A, S, O]),\n                                atom_codes(Ac, A), atom_codes(Sj, S), atom_codes(Ob, O).\n\n%Cada vez devolver├í una de las acciones, haciendo que las posibilidades de la gram├ítica aumenten exponencialmente.\nchoose_one_action(StoryI, [Js | JSR], Ac) :- get_action(StoryI, Js, Ac).\nchoose_one_action(StoryI, [Js | JSR], Ac) :- choose_one_action(StoryI, JSR, Ac).\n\n\nget_action(StoryI, json([score = Q | R]), Ac) :- A1 = score(Q), get_action(StoryI, json(R), A2), Ac = [A1, A2].\nget_action(StoryI, json([event = Q | R]), Ac) :- substitute_characters(St, Q, ResInt), Ac = event(ResInt).\nget_action(StoryI, json([P = Q | R]), Ac) :- P \\== 'score', P \\== 'event', get_action(StoryI, json(R), Ac).\n\n\n/* Sustituye los par├ímetros de la acci├│n: P = horse, \"___ rides X\" -> \"cat rides horse\" */\n\nsubstitute_characters(StoryI, Ac, Result) :- substitute_main_character(StoryI, Ac, MidR),\n                                              substitute_secondary_character(StoryI, MidR, Result).\n\nsubstitute_main_character(StoryI, Ac, Result) :- main_character(MC),\n                                                  atomic_list_concat(Words, 'X', Ac),\n                                                  atomic_list_concat(Words, MC, Result).\n\nsubstitute_secondary_character(StoryI, Ac, Result) :- get_secondary_character(StoryI, SC),\n                                                      atomic_list_concat(Words, '___', Ac),\n                                                      atomic_list_concat(Words, SC, Result).\n\nsubstitute_secondary_character(StoryI, Ac, Result) :- main_character(SC),\n                                                      atomic_list_concat(Words, '___', Ac),\n                                                      atomic_list_concat(Words, SC, Result). \n\nsubstitute_spaces(Ac, Result) :- atomic_list_concat(Words, ' ', Ac), atomic_list_concat(Words, '_', Result). \n\n/* Frase trivial */\n/* Genera frases sobre el tiempo, el d├¡a/hora, el cima... */\n\nfrase_trivial(T) :- calendar_sentence(T).\nfrase_trivial(T) :- climate_sentence(T).\nfrase_trivial(T) :- calendar_sentence(Cal), climate_sentence(Cl), append(Cal, Cl, T).\n\n\n\ncalendar_sentence(F) :- get_time(T), stamp_date_time(T, D, local), calendar(D, F).\n\ncalendar(Date, [date(Yr, Mth, Day)]) :- mn_date(Date, Yr, Mth, Day).\ncalendar(Date, [time(Hr, Mn)]) :- mn_time(Date, Hr, Mn).\ncalendar(Date, [date(Yr, Mth, Day), time(Hr, Mn)]) :- mn_date(Date, Yr, Mth, Day), mn_time(Date, Hr, Mn).\n\nmn_date(Date, Yr, Mth, Day) :- date_time_value(date, Date, date(Y, M, D)), atom_number(Yr, Y),\n                    atom_number(Mth, M), atom_number(Day, D).\n\nmn_time(Date, Hr, Mn) :- date_time_value(time, Date, time(H, M, _)), atom_number(Hr, H), atom_number(Mn, M).\n\n\n\n\nclimate_sentence(F) :- sky(S), wind(W), temp(T), append(S, W, Int), append(Int, T, F).\n\nsky([clear(sky)]).\nsky([cloudy(sky)]).\nsky([rainy(sky)]).\n\nwind([windy(wind)]).\nwind([-windy(wind)]).\n\ntemp([cold(temperature)]).\ntemp([hot(temperature)]).\ntemp([warm(temperature)]).\ntemp([nice(temperature)]).\n\n/* PROBLEMA: no utiliza los possible/consequence de este fichero (overide en output.json) */\n\n\npossible(disney, St, shoot(X, Y), 1.0) :-\n   member(alive(X), St),\n   member(alive(Y), St),\n   X \\== Y.\n\nconsequence(disney, shoot(_, Y), [dead(Y), -alive(Y)], 1.0).\n\n\npossible(disney, St, learnto(X, Y), C) :-\n    domain(disney, St, animal, X, C1),\n    domain(disney, St, activity, Y, C2),\n    C is C1 * C2,    \\+member(capableof(X, Y), St).\n\nconsequence(disney, learnto(X, Y), [capableof(X, Y)], 1.0).\n\n\npossible(disney, St, eat(X, Y), 1.0) :-\n   member(alive(X), St),\n   member(human(X), St),\n   member(food(Y), St).\n\nconsequence(disney, eat(X, Y), [-hungry(X), -edible(Y)], 1.0).\n\nconsequence(disney, isa(X, animal), [capableof(X, talk)], 0.5).\n\n/* Hechos espontaneos */\n% [isa(dog,animal),doesfor(dog,run,fun),-capableof(dog,ride_horse)]\n\n/* Idea: en cualquier momento puede ocurrir algo (p.e.: lluvia), la historia debe mostrar las consecuencias\n(p.e.: tal personaje usa el paraguas)\n[startsto, rain], [use(dog, umbrella)], [wet(horse)]. */\n\n% Devuelve el efecto de lo que ocurre (para todos los personajes de los NP).\nhappen(WV, F, St, NP, C) :- spontaneous_fact(WV, H, C), append(St, NP, L), apply(H, L, Ef), F = [H | Ef].\n\napply(H, NP, Ef) :- all_characters(Pers, NP), maplist(spontaneous_effect(H), Pers, Ef).\n\n/* Obtiene los personajes de los narrative points (TODO: Hacerlo con todos los personajes que aparecen: personajes\n   introducidos previamente) */\n\nall_characters(Pers, NP) :- findall(P, character(P, NP), Pers).\n\n% TODO: Hacer personajes dependientes del dominio (p.e.: disney = animal, other = human, pixar = toy...)\n\ncharacter(Pers, [P | NP]) :- domain(_, _, animal, Pers, _), is_character(Pers, [P | NP]).\nis_character(Pers, [P | NP]) :- (has_character(Pers, P), !) ; character(Pers, NP).\nhas_character(Pers, SNP) :- format(atom(A), \"~w\", SNP), sub_string(A, _, _, _, Pers).\n\n/* Presentaci├│n de personajes */\n\nintroduce_secondary_characters(StoryI, NP, F) :-\n                      all_characters(C, NP), secondary_unintroduced_characters(StoryI, C, Pers),\n                      secondary_character_frase(StoryI, Pers, F).\n\n\nsecondary_character_frase(_, [], []).\nsecondary_character_frase(StoryI, [P | RP], F) :-\n                  (secondary_character_frase(StoryI, RP, Q), \\+is_introduced(StoryI, P), establish_relation(P, R),\n                  F = [secondary_character(P) , R | Q]) ; is_introduced(StoryI, P),\n                  secondary_character_frase(StoryI, RP, F).\n\n\nsecondary_unintroduced_characters(_, [], []).\nsecondary_unintroduced_characters(StoryI, [P | RP], Pers) :-\n                  (\\+is_introduced(StoryI, P), secondary_unintroduced_characters(StoryI, RP, Q), Pers = [P | Q], !) ;\n                  secondary_unintroduced_characters(StoryI, RP, Pers).\n\nget_secondary_character(StoryI, P) :- all_characters(Pers, StoryI), get_one(Pers, P), \\+ main_character(P).\n\nget_one([P | RP], Personaje) :- Personaje = P.\nget_one([P | RP], Personaje) :- get_one(RP, Personaje).\n\n/* TODO: Filtrar palabras con substrings de personaje dentro (p.e.: cat, stacatto) */\nis_introduced([F | StoryI], P) :- (format(atom(A), \"~w\", F), sub_string(A, _, _, _, P), !) ; is_introduced(StoryI, P).\n\n\n\n/* PROBLEMA: Al hacer backtrack no pone los personajes secundarios (ya se han introducido!!!) */\n\n/* Introducci├│n de personajes */\n/*\nintroduce_characters(NP, F) :- all_characters(Pers, NP), introduce_all(Pers, F). %, character_frase(Pers, F).\n\nintroduce_all([], []).\nintroduce_all([P | PR], F) :- (\\+ secondary_character(P), \\+ main_character(P),\n                            assert(secondary_character(P)), introduce_all(PR, Q), establish_relation(P, R),\n                            F = [secondary_character(P) , R | Q]) ; introduce_all(PR, F).\n*/\n\n%introduce_all([_ | PR], F) :- introduce_all(PR, F).\n\n\nintroduce_main_characters(NP, F) :- all_characters(Pers, NP), introduce_all_main(Pers), main_character_frase(Pers, F).\nintroduce_all_main([]).\nintroduce_all_main([P | PR]) :- (\\+ main_character(P), assert(main_character(P)),\n                              introduce_all_main(PR), !) ; introduce_all_main(PR).\n\n\n%introduce_main_characters(NP, F) :- all_characters(Pers, NP), main_character_frase(Pers, F).\n\nmain_character_frase([], []).\nmain_character_frase([P | RP], F) :- main_character_frase(RP, Q), F = [main_character(P) | Q].\n\n\n%introduce_main_characters(NP, F) :- all_characters(Pers, NP), introduce_all_main(Pers, F).\n\n/*\nintroduce_all_main([], []).\nintroduce_all_main([P | PR], F) :- (\\+ secondary_character(P), \\+ main_character(P),\n                            assert(main_character(P)), introduce_all_main(PR, Q),\n                            F = [main_character(P) | Q], !) ; introduce_all_main(PR, F).\n*/\n\n%introduce_all_main([_ | PR], F) :- introduce_all_main(PR, F).\n\n\n/*\nare_characters_introduced(NP) :- all_characters(Pers, NP), are_all_introduced(Pers).\nare_all_introduced([]).\nare_all_introduced([P | PR]) :- ((secondary_character(P), !) ; main_character(P)), are_all_introduced(PR).\n*/\n\n/* Eliminar personajes introducidos */\n\nretract_all_characters([]).\nretract_all_characters([P | NP]) :- main_character(P), retract(main_character(P)), retract_all_characters(NP).\n%retract_all_characters([P | NP]) :- secondary_character(P), retract(secondary_character(P)), retract_all_characters(NP).\n\nretract_main :- findall(P, main_character(P), M), retract_main_characters(M).\n%retract_secondary :- findall(P, secondary_character(P), M), retract_secondary_characters(M).\n\nretract_main_characters([]).\nretract_main_characters([P | RP]) :- main_character(P), retract(main_character(P)), retract_main_characters(RP).\n\nretract_secondary_characters([]).\nretract_secondary_characters([P | RP]) :- secondary_character(P), retract(secondary_character(P)),\n                                          retract_secondary_characters(RP).\n\nall_introduced(Pers) :- findall(P, main_character(P), Pers).\n\nretract_all :- all_introduced(Pers), retract_all_characters(Pers).\n\n\n\nspontaneous_fact(_, start(rain), 0.5).\nspontaneous_fact(_, start(fight), 0.4).\n\n\n\nspontaneous_effect(start(rain), P, use(P, umbrella)).\nspontaneous_effect(start(rain), P, get(P, wet)).\n\nspontaneous_effect(sing(people), P, sing(P, aloud)).\nspontaneous_effect(sing(people), P, sing(P, happily)).\nspontaneous_effect(sing(people), P, sing(P, sadly)).\n\nspontaneous_effect(start(fight), P, get(P, angry)).\nspontaneous_effect(start(fight), P, get(P, scared)).\nspontaneous_effect(start(fight), P, preparefor(P, fight)).\n\n/* Relaciones (con otros personajes o entre personajes) */\n/* Idea: los personajes se relacionan entre s├¡ (hermanos/amigos/enemigos), con consecuencias\n   parent(P1, P2) -> love(P1, P2)\n   Idea: propiedades de los personajes (male, female, single, married)\n   Idea: introducir personajes para establecer una relaci├│n, en lugar de hacerlo aleatoriamente\n   Idea: start(fight) -> enemy(P1, P2), single(P) -> looksfor(lover) */\n\n\nestablish_relation(P2, F) :- main_character(P1), P1 \\= P2, relation_fact(P1, P2, F).\nestablish_relation(P2, F) :- main_character(P1), P1 \\= P2, relation_fact(P1, P2, F1),\n                              relation_effect(F1, F2), append(F1, F2, F).\n\n\nrelation_fact(P1, P2, brother(P1, P2)).\nrelation_fact(P1, P2, friend(P1, P2)).\nrelation_fact(P1, P2, enemy(P1, P2)).\nrelation_fact(P1, P2, parent(P1, P2)).\n\nrelation_effect(brother(P1, P2), love(P1, P2)).\nrelation_effect(brother(P1, P2), hate(P1, P2)).\nrelation_effect(friend(P1, P2), hangout(P1, P2)).\nrelation_effect(enemy(P1, P2), hate(P1, P2)).\nrelation_effect(parent(P1, P2), love(P1, P2)).\n\n\n\n\n%domain(disney, animal, dog).\n%domain(kafka, animal, dog).\ndomain(_, _, animal, dog, 1.0).\ndomain(_, _, animal, cat, 1.0).\ndomain(_, _, animal, horse, 1.0).\ndomain(_, _, activity, run, 1.0).\ndomain(_, _, activity, ride_horse, 1.0).\ndomain(_, _, posword, fun, 1.0).\ndomain(_, _, posword, joy, 1.0).\ndomain(_, _, negword, old, 1.0).\n\n\n% ontology\n\ndomain(D, St, alive, X, V) :- domain(D, St, animal, X, V).\ndomain(D, St, animal, X, V) :- domain(D, St, human, X, V).\n\n"}]}
